root{
    lt_proc_desc{"process a stream with a letter transducer"}
    analysis_desc{"morphological analysis (default behavior)"}
    bilingual_desc{"lexical transfer"}
    case_sensitive_desc{"use the literal case of the incoming characters"}
    debugged_gen_desc{"morph. generation with all the stuff"}
    decompose_nouns_desc{"Try to decompound unknown words"}
    generation_desc{"morphological generation"}
    ignored_chars_desc{"specify file with characters to ignore"}
    restore_chars_desc{"specify file with characters to diacritic restoration"}
    tagged_gen_desc{"morphological generation keeping lexical forms"}
    tagged_nm_gen_desc{"same as -l but without unknown word marks"}
    non_marked_gen_desc{"morph. generation without unknown word marks"}
    surf_bilingual_desc{"lexical transfer with surface forms"}
    post_generation_desc{"post-generation"}
    inter_generation_desc{"inter-generation"}
    sao_desc{"SAO annotation system input processing"}
    transliteration_desc{"apply transliteration dictionary"}
    version_desc{"version"}
    null_flush_desc{"flush output on the null character"}
    dictionary_case_desc{"use dictionary case instead of surface"}
    careful_case_desc{"use dictionary case if present, else surface"}
    no_default_ignore_desc{"skips loading the default ignore characters"}
    show_weights_desc{"Print final analysis weights (if any)"}
    analyses_desc{"Output no more than N analyses (if the transducer is weighted, the N best analyses)"}
    weight_classes_desc{"Output no more than N best weight classes (where analyses with equal weight constitute a class)"}
    compound_max_elements_desc{"Set compound max elements"}
    help_desc{"show this help"}
    usage{"USAGE: "}
    version{" version "}


    lt_append_desc{"add sections to a compiled transducer"}
    keep_desc{"in case of section name conflicts, keep the one from the first transducer"}
    single_desc{"treat input transducers as one-sided"}

    lt_apply_acx_desc{"apply an ACX file to a compiled transducer"}

    lt_comp_desc{"build a letter transducer from a dictionary"}
    debug_desc{"insert line numbers before each entry"}
    keep_boundaries_desc{"keep morpheme boundaries"}
    var_desc{"set language variant"}
    alt_desc{"set alternative (monodix)"}
    var_left_desc{"set left language variant (bidix)"}
    var_right_desc{"set right language variant (bidix)"}
    expect_hfst_desc{"expect HFST symbols"}
    no_split_desc{"don't attempt to split into word and punctuation sections"}
    jobs_desc{"use one cpu core per section when minimising, new section after 50k entries"}
    verbose_desc{"compile verbosely"}

    lt_compose_desc{"compose transducer1 with transducer2"}
    inverted_desc{"run composition right-to-left on transducer1"}
    anywhere_desc{"don't require anchored matches, let transducer2 optionally compose at any sub-path"}

    lt_expand{"expand the contents of a dictionary file"}
    lt_invert_desc{"reverse the direction of a compiled transducer"}

    lt_paradigm_desc{"generate listings from a compiled transducer"}
    analyser_desc{"FST is an analyser (tags on the right)"}
    exclude_desc{"disregard paths containing TAG"}
    sort_desc{"alphabetize the paths for each pattern"}

    lt_print_desc{"dump a transducer to text in ATT format"}
    alpha_desc{"print transducer alphabet"}
    use_hfst_desc{"use HFST-compatible character escapes"}

    lt_restrict_desc{"remove paths from a transducer"}
    minimise_desc{"minimise transducers after deleting paths"}

    lt_tmxcomp_desc{"build a letter transducer from a TMX translation memory"}
    origin_code_desc{"the language code to be taken as lang1"}
    meta_code_desc{"the language code to be taken as lang2"}
    input_language{"input language"}
    output_language{"output language"}

    lt_tmxproc_desc{"process a stream with a letter transducer"}

    lt_trim_desc{"trim a transducer to another transducer"}
    match_section_desc{"A section with this name (id@type) will only be trimmed against a section with the same name. This argument may be used multiple times."}

    LTTB1000{"ERROR LTTB1000: Invalid or no argument for {option}"}
    LTTB1001{"ERROR LTTB1001: In {node_doc_url} on line {line_number}: Missing value attribute."}
    LTTB1002{"ERROR LTTB1002: In {node_doc_url} on line {line_number}: Expected a single character in value attribute, but found {value_size}."}
    LTTB1003{"ERROR LTTB1003: In {node_doc_url} on line {line_number}: Expected <char> but found <{node_name}>."}
    LTTB1004{"ERROR LTTB1004: In {node_doc_url} on line {line_number}: Expected <equiv-char> but found <{node_name}>."}
    LTTB1005{"ERROR LTTB1005: Unable to access \"{file_name}\"."}
    LTTB1006{"ERROR LTTB1006: Invalid format in file \"{file_name}\" on line {line_number}."}
    LTTB1007{"WARNING LTTB1007: Multiple fsts in \"{file_name}\" will be disjuncted."}
    LTTB1008{"ERROR LTTB1008: Transducer contains epsilon transition to a final state. Aborting."}
    LTTB1009{"ERROR LTTB1009: Transducer contains initial epsilon loop. Aborting."}
    LTTB1010{"ERROR LTTB1010: Cannot create empty buffer."}
    LTTB1011{"ERROR LTTB1011: Parse error at the end of input."}
    LTTB1012{"ERROR LTTB1012: Invalid dictionary (hint: the {side} side of an entry is empty)."}
    LTTB1013{"ERROR LTTB1013: Invalid dictionary (hint: entry on the {side} beginning with whitespace)."}
    LTTB1014{"ERROR LTTB1014: On line {line_number}: Missing alphabet symbols."}
    LTTB1015{"WARNING LTTB1015: Cannot insert <t/> from empty input. Ignoring. (You probably want to specify exact tags when deleting a word.)"}
    LTTB1016{"ERROR LTTB1016: On line {line_number}: Non-empty element \"<{name}>\" should be empty."}
    LTTB1017{"ERROR LTTB1017: On line {line_number}: Undefined symbol \"{symbol}\"."}
    LTTB1018{"ERROR LTTB1018: On line {line_number}: Invalid specification of element \"<{name}>\" in this context."}
    LTTB1019{"ERROR LTTB1019: On line {line_number}: Invalid construction."}
    LTTB1020{"ERROR LTTB1020: On line {line_number}: Expected \"<{slash_element}>\"."}
    LTTB1021{"WARNING LTTB1021: On line {line_number}: Entry begins with space."}
    LTTB1022{"ERROR LTTB1022: On line {line_number}: Paradigm refers to itself \"{paradigm_name}\"."}
    LTTB1023{"ERROR LTTB1023: On line {line_number}: Undefined paradigm \"{paradigm_name}\"."}
    LTTB1024{"ERROR LTTB1024: On line {line_number}: Invalid entry token."}
    LTTB1025{"ERROR LTTB1025: On line {line_number}: \"<{element_name}>\" element must specify non-void \"{attr_name}\" attribute."}
    LTTB1026{"ERROR LTTB1026: On line {line_number}: Parse error."}
    LTTB1027{"ERROR LTTB1027: On line {line_number}: Invalid inclusion of \"<{element_name}>\" into \"<{compiler_entry_element}>\"."}
    LTTB1028{"ERROR LTTB1028: On line {line_number}: Invalid node \"<{element_name}>\"."}
    LTTB1029{"ERROR LTTB1029: I/O Error writing."}
    LTTB1030{"ERROR LTTB1030: Out of range: {value}."}
    LTTB1031{"ERROR LTTB1031: Can't access file {file_name}."}
    LTTB1032{"WARNING LTTB1032: Matching case-sensitively since processor state size >= {max_case_insensitive_state_size}"}
    LTTB1033{"ERROR LTTB1033: Unsupported transducer type for \"{transducer_first}\"."}
    LTTB1034{"WARNING LTTB1034: CompoundAnalysis's MAX_COMBINATIONS exceeded for \"{input_word}\"\n"
             "                  gave up at char {index} \"{char}\"."}
    LTTB1035{"WARNING LTTB1035: Decomposition symbol {symbol} not found."}
    LTTB1036{"ERROR LTTB1036: Unable to rewind file."}
    LTTB1037{"ERROR LTTB1037: Unexpected trailing backslash."}
    LTTB1038{"WARNING LTTB1038: section \"{section}\" appears in both transducers and will be overwritten!"}
    LTTB1039{"ERROR LTTB1039: -l specified, but mode is lr."}
    LTTB1040{"ERROR LTTB1040: -r specified, but mode is rl."}
    LTTB1041{"WARNING LTTB1041: section {section_name} is empty! Skipping it..."}
    LTTB1042{"WARNING LTTB1042: section {section_name} had no final state after composing! Skipping it..."}
    LTTB1043{"ERROR LTTB1043: Composition gave empty transducer!"}
    LTTB1044{"WARNING LTTB1044: unsupported locale, fallback to \"C\""}
    LTTB1045{"WARNING LTTB1045: section {section_name} was not found in both transducers! Skipping if in just one..."}
    LTTB1046{"ERROR LTTB1046: Trimming gave empty transducer!\n"
             "Hint: There are no words in bilingual dictionary that match words in both monolingual dictionaries?"}
    LTTB1047{"ERROR LTTB1047: Opening an unended sequence."}
    LTTB1048{"ERROR LTTB1048: Ending an unopened sequence."}
    LTTB1049{"ERROR LTTB1049: Using labels outside of a sequence."}
    LTTB1050{"ERROR LTTB1050: Parsing regexp."}
    LTTB1051{"ERROR LTTB1051: Unable to lowercase string \"{string}\".\n"
             "Error code: {error_name}"}
    LTTB1052{"ERROR LTTB1052: Unable to uppercase string \"{string}\".\n"
             "Error code: {error_name}"}
    LTTB1053{"ERROR LTTB1053: Unable to titlecase string \"{string}\".\n"
             "Error code: {error_name}"}
    LTTB1054{"ERROR LTTB1054: Caseless string comparison failed on \"{string_a}\" and \"{string_b}\".\n"
             "Error code: {error_name}"}
    LTTB1055{"ERROR LTTB1055: Trying to link nonexistent states ({source}, {target}, {tag})."}
    LTTB1056{"ERROR LTTB1056: Empty set of final states."}
    LTTB1057{"ERROR LTTB1057: Couldn't find {f_src}, {g_src} in state map."}
    LTTB1058{"ERROR LTTB1058: Failed to write uint64_t."}
    LTTB1059{"ERROR LTTB1059: Transducer has features that are unknown to this version of lttoolbox - upgrade!"}
    LTTB1060{"ERROR LTTB1060: Unable to parse {type}."}
    LTTB1061{"ERROR LTTB1061: Malformed input stream."}
    LTTB1062{"ERROR LTTB1062: FST has features that are unknown to this version of lttoolbox - upgrade!"}
    LTTB1063{"ERROR LTTB1063: Could not read {number} expected bytes from stream."}
    LTTB1064{"ERROR LTTB1064: Can't deserialise {size} byte integer type: Can't deserialise size."}
    LTTB1065{"ERROR LTTB1065: Can't deserialise {size} byte integer type: Can't deserialise byte."}
    LTTB1066{"ERROR LTTB1066: Can't serialise const {size_a} byte integer type: Can't serialise size {size_b}."}
    LTTB1067{"ERROR LTTB1067: Can't serialise const {size} byte integer type: Can't serialise byte {byte}."}
}
